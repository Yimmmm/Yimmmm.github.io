<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis 补充问题]]></title>
    <url>%2Fpost%2F36a6d7d9.html</url>
    <content type="text"><![CDATA[关于上次没有理清楚的几个问题1.字符串39字节的计算规则，以及变为44以后sdsshr的变化12345678910111213typedef struct redisObject &#123; unsigned type:4;// 对象类型 unsigned encoding:4;// 内部编码类型 unsigned lru:REDIS_LRU_BITS; // LRU计时时钟 int refcount;// 引用计数器 void *ptr;// 数据指针&#125; robj;struct sdshdr &#123; unsigned int len; unsigned int free; char buf[];&#125;; 原文注解： 12345REDIS_ENCODING_EMBSTR_SIZE_LIMIT set to 39. The new value is the limit for the robj + SDS header + string + null-term to stay inside the 64 bytes Jemalloc arena in 64 bits systems. 当时被这篇文章坑了，写的不太对，花了我好长时间… 1https://www.zhihu.com/question/25624589 源码之下无秘密，我们从源码来推 sizeof(struct sdshdr) == 8，也就是说，最后的buf成员未计入。 sizeof(redisObject) + sizeof(sdshdr) +sizeof(‘\0’)= 16 + 8 + 1=25。 也就是在embstr下，最少占用空间为25，剩下字符串最大空间为64-25=39。 关于39为什么变为44，主要来自于这个commit 12https://github.com/antirez/redis/commit/f15df8ba5db09bdf4be58c53930799d82120cc34#diff-43278b647ec38f9faf284496e22a97d5 Redis本身针对短字符串的embstr自然会使用最小的sdshdr8，而sdshdr8与之前的sdshdr相比正好减少了5个字节（sdsdr8 = uint8_t 2 + char = 12+1 = 3, sdshdr = unsigned int 2 = 4 2 = 8）,所以其能容纳的字符串长度增加了5个字节变成了44。 2.hash中load_factor(负载因子)怎么样大于1首先负载因子的计算公式为：load_factor =used / size负载因子 = 当前结点数/桶的大小,简单点理解就是填充率也就是说在没有Rehash以前，桶的大小是固定的，根据Used增加，负载因子可以小于1也可以大于1. 3.hash中rehashidx的作用它表示上次rehash时在ht[0]的下标位置，也就是下一个需要rehash的项在ht[0]中的索引。在rehash的过程中，对redis的查询、更新操作首先会在hash0中查找，没有找到，然后转到hash1中操作 以下是Rehash的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int dictRehash(dict *d, int n) &#123; int empty_visits = n*10; /* Max number of empty buckets to visit. */ if (!dictIsRehashing(d)) return 0; while(n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123; dictEntry *de, *nextde; /* Note that rehashidx can't overflow as we are sure there are more * elements because ht[0].used != 0 */ assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx); while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123; d-&gt;rehashidx++; if (--empty_visits == 0) return 1; &#125; de = d-&gt;ht[0].table[d-&gt;rehashidx]; /* Move all the keys in this bucket from the old to the new hash HT */ while(de) &#123; uint64_t h; nextde = de-&gt;next; /* Get the index in the new hash table */ h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask; de-&gt;next = d-&gt;ht[1].table[h]; d-&gt;ht[1].table[h] = de; d-&gt;ht[0].used--; d-&gt;ht[1].used++; de = nextde; &#125; d-&gt;ht[0].table[d-&gt;rehashidx] = NULL; d-&gt;rehashidx++; &#125; /* Check if we already rehashed the whole table... */ if (d-&gt;ht[0].used == 0) &#123; zfree(d-&gt;ht[0].table); d-&gt;ht[0] = d-&gt;ht[1]; _dictReset(&amp;d-&gt;ht[1]); d-&gt;rehashidx = -1; return 0; &#125; /* More to rehash... */ return 1;&#125; 可以看到，rehash是以bucket(桶)为基本单位进行渐进式的数据迁移的，每步完成一个bucket的迁移，直至所有数据迁移完毕。一个bucket对应哈希表数组中的一条entry链表。新版本的dictRehash()还加入了一个最大访问空桶数(empty_visits)的限制来进一步减小可能引起阻塞的时间。 4.Redis为什么是单线程的 官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。但是最后说Redis4.0可能会采用多线程。 5.watch没有演示成功的原因当天晚上是演示成功的，返回结果是nil（图1）,执行成功返回的是OK（图2），不是报错，报错是语句错误才会发生(图3)。]]></content>
      <categories>
        <category>fenlei</category>
      </categories>
      <tags>
        <tag>Testing</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis内部实现原理]]></title>
    <url>%2Fpost%2F7b25d017.html</url>
    <content type="text"><![CDATA[是完全开源免费的，用C语言编写的，遵守BSD协议,是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库。 数据类型 string 字符串 hash 哈希 list 列表 set 集合 zset 有序集合 实现方式 数据结构SDS 简单动态字符串(Simple Dynamic String） 数据结构12345678910struct sdshdr &#123; // 记录 buf 数组中已使用字节的数量 // 等于 SDS 所保存字符串的长度 int len; // 记录 buf 数组中未使用字节的数量 int free; // 字节数组，用于保存字符串 char buf[];&#125;; 与C字符串相比优势 二进制安全 C是通过特殊字符（\0）结束 Redis中len属性通过len来 减少内存重分配次数 内存预分配 修改之后的字符串长度&lt;1M,则分配与当前字符串相同的空间 修改之后的字符串长度&gt;1M,则分配空间为1M 惰性释放 当字符串缩短时，空间不会释放，而是标识free 链表123456789101112typedef struct listNode &#123; // 前置节点 struct listNode *prev; // 后置节点 struct listNode *next; // 节点的值 void *value;&#125; listNode; 特性 双端：获取某个节点的前置节点和后置节点的复杂度都是 O(1) 无环：prev和next 指针都指向 NULL 带表头指针和表尾指针：获取链表中节点数量的复杂度为 O(1) 带链表长度计数器：获取链表数量的复杂度为 O(1) 使用 列表键 发布与订阅 慢查询 监视器 字典12345678910111213141516typedef struct dictht &#123; // 哈希表数组 dictEntry **table; // 哈希表大小 unsigned long size; // 哈希表大小掩码，用于计算索引值 // 总是等于 size - 1 unsigned long sizemask; // 该哈希表已有节点的数量 unsigned long used;&#125; dictht; 属性rehashidx：记录rehash目前的进度，如果没有进行rehash那么值为-1 hash冲突Redis使用地址法（separate chaining）来解决键冲突，为了速度考虑， 程序总是将新节点添加到链表的表头位置。 rehash条件 load_factor = ht[0].used / ht[0].size 当服务器没有执行BGSAVE或者BGREWRITEAOF命令, load_factor &gt;=1，进行扩展 当服务器执行BGSAVE或者BGREWRITEAOF命令, load_factor&gt;=5，进行扩展 当 load_factor &lt; 0.1 时，进行收缩 渐进式rehash过程 ht[1]hash表分配空间，同时持有两个哈希表 扩展操作 ht[1] = ht[0].used * 2 收缩操作 ht[1] = ht[0].used 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0，表示 rehash 工作正式开始 每次增加、删除、更新或者查找，程序除了执行指定的操作外，还将ht[0]还是表在rehashidx上的所有键rehash到ht[1],rehashidx++ 将ht[0]上的所有键rehash到ht[1]上以后，rehashidx值设置为-1，表示完成 迁移完成之后，ht[1] = ht[0] ,释放ht[0]，在ht[1]新建一个空白的hash表 跳跃表123456789101112131415161718192021222324typedef struct zskiplistNode &#123; // 后退指针 struct zskiplistNode *backward; // 分值 double score; // 成员对象 robj *obj; // 层 struct zskiplistLevel &#123; // 前进指针 struct zskiplistNode *forward; // 跨度 unsigned int span; &#125; level[]; &#125; zskiplistNode; header ：指向跳跃表的表头节点。 tail ：指向跳跃表的表尾节点。 level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内），幂次定律，随机1-32。 length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。 幂次定律 整数集合123456789**typedef struct intset &#123; // 编码方式 uint32_t encoding; // 集合包含的元素数量 uint32_t length; // 保存元素的数组 int8_t contents[];&#125; intset;** 升级 编码类型 最小值 最大值 int16_t -32786 32767 int32_t -2147283648 2147283647 int64_t … … Q1:为什么要升级？ 压缩列表 压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型数据结构。 压缩列表只记录前一个字节点的长度 连锁更新，最坏的复杂度O(N²) 对象 Redis并没有直接使用上面的数据结构来实现，而是基于这些数据结构创建了一个对象系统，包括字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种对象，每种用到了上面至少一种数据类型 1234567891011121314151617typedef struct redisObject &#123; // 类型 unsigned type:4; // 编码 unsigned encoding:4; // 指向底层实现数据结构的指针 void *ptr; //引用计数器 int refcount // ...&#125; robj; 类型 对象 对象名称 REDIS_STRING 字符串对象 REDIS_LIST 列表对象 REDIS_HASH 哈希对象 REDIS_SET 集合对象 REDIS_ZSET 有序集合对象 底层实现 类型 编码 对象 REDIS_STRING REDIS_ENCODING_INT 使用整数值实现的字符串对象。 REDIS_STRING REDIS_ENCODING_EMBSTR 使用 embstr 编码的简单动态字符串实现的字符串对象。 REDIS_STRING REDIS_ENCODING_RAW 使用简单动态字符串实现的字符串对象。 REDIS_LIST REDIS_ENCODING_ZIPLIST 使用压缩列表实现的列表对象。 REDIS_LIST REDIS_ENCODING_LINKEDLIST 使用双端链表实现的列表对象。 REDIS_HASH REDIS_ENCODING_ZIPLIST 使用压缩列表实现的哈希对象。 REDIS_HASH REDIS_ENCODING_HT 使用字典实现的哈希对象。 REDIS_SET REDIS_ENCODING_INTSET 使用整数集合实现的集合对象。 REDIS_SET REDIS_ENCODING_HT 使用字典实现的集合对象。 REDIS_ZSET REDIS_ENCODING_ZIPLIST 使用压缩列表实现的有序集合对象。 REDIS_ZSET REDIS_ENCODING_SKIPLIST 使用跳跃表和字典实现的有序集合对象。 内存回收 通过引用计数法进行内存回收，若果refcount=0，则内存会被释放 对象共享 服务器初始化，创建一万个字符串对象，包含1-9999的所有整数值 Q2:为什么不共享包含字符串的对象或者多值对象？ 过期策略 策略 优点 缺点 定时删除 内存友好 CPU不友好 惰性删除 CPU友好 内存泄漏 定期删除 折中 执行时长和频率不好控制 持久化RDB持久化 将数据库的快照以二进制压缩文件的方式保存到磁盘 间隔自动保存 时间 次数 900 1 300 10 60 10000 AOF持久化 将所有写入命令及相关参数以协议文本的方式写入文件并持久保存磁盘 AOF 持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。 AOF持久化的安全与效率appendfsync always everysec no AOF重写 REWRITE: 在主线程中重写AOF，会阻塞工作线程，在生产环境 中很少使用，处于废弃状态； BGREWRITE: 在后台（子进程）重写AOF, 不会阻塞工作线程，能正常服务，此方法最常用。 AOF通过记录命令来记录数据库状态的，所以AOF文件的大小随着时间的流逝一定会越来越大，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件。 Q3：子进程重写期间，新的命令进来了怎么办？ 事件Redis服务器是一个事件驱动程序 文件事件 时间事件 ServerCron 每100ms执行一次 多机实现复制旧版复制 同步操作，从服务器更新至主服务器的状态 命令传播，主服务器发送命令进行同步 新版复制 复制偏移量 复制积压缓冲区，固定长度，FIFO，1M 服务器运行ID，启动时生成的40哥随机十六进制字符 心跳检测 每秒一次的频率 连接状态 检测命令丢失 哨兵 Sentinal Sentinal本质上只是一个在特殊模式下的Redis服务器 Sentinal初始化完成以后成为主服务器的客户端 命令连接 订阅连接 Q4:为什么会有两个连接？ 选举领头Sentinel 发现主服务器下线以后，都认为自己是局部领头 局部领头，先到先得 半数以上选举成功，没有接着选 故障转移 删除列表中处于下线或者断线的从服务器 删除列表中所有最近五秒没有回复过领头Sentinel命令的服务器 删除与主服务器超过 down-after-milliseconds * 10 ms 开始优先级排序 最高优先级-&gt;复制偏移量-&gt;运行服务器ID最小 集群 使用一致性hash实现，0-16384个slots 独立功能事务 非EXEC、DISCARD、WATCH、MULTI WATCH命令 WATCH命令是一个乐观锁，可以监视任意多的键，在EXEC执行之前会检查是否有值进行修改]]></content>
  </entry>
</search>
