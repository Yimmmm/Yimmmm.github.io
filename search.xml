<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用iTerm时，SZ下载文件遇到的问题]]></title>
    <url>%2Fpost%2F5491a6a3.html</url>
    <content type="text"><![CDATA[情景描述在mac环境下，使用iTerms rz，sz是Linux/Unix同Windows进行ZModem文件传输的命令行工具，优点就是不用再开一个sftp工具登录上去上传下载文件。 环境 mac iTerm2 szTest 解决方法优化小技巧 问价下载前先进行压缩]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>iterm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始出发]]></title>
    <url>%2Fpost%2F59ab6f67.html</url>
    <content type="text"><![CDATA[为什么之前不写博客毕业五年多了，都是自己将知识点记录在笔记中，从来没有对外发表过，主要有以下几个误区 怕自己技术水平和写作能力不够好 网上已经有人写了，并且写的很好 写博客会花费大量的时间 写博客是为了给别人看的 现在为什么开始写了 发现学的技术没有体系化管理 技术开放心态不够 写博客能对问题的认识更加深入 写博客的标准生活类 要求乐观向上 技术类 清晰 细致]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis内部实现原理]]></title>
    <url>%2Fpost%2F7b25d017.html</url>
    <content type="text"><![CDATA[是完全开源免费的，用C语言编写的，遵守BSD协议,是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库。 数据类型 string 字符串 hash 哈希 list 列表 set 集合 zset 有序集合 实现方式 数据结构SDS 简单动态字符串(Simple Dynamic String） 数据结构12345678910struct sdshdr &#123; // 记录 buf 数组中已使用字节的数量 // 等于 SDS 所保存字符串的长度 int len; // 记录 buf 数组中未使用字节的数量 int free; // 字节数组，用于保存字符串 char buf[];&#125;; 与C字符串相比优势 二进制安全 C是通过特殊字符（\0）结束 Redis中len属性通过len来 减少内存重分配次数 内存预分配 修改之后的字符串长度&lt;1M,则分配与当前字符串相同的空间 修改之后的字符串长度&gt;1M,则分配空间为1M 惰性释放 当字符串缩短时，空间不会释放，而是标识free 链表123456789101112typedef struct listNode &#123; // 前置节点 struct listNode *prev; // 后置节点 struct listNode *next; // 节点的值 void *value;&#125; listNode; 特性 双端：获取某个节点的前置节点和后置节点的复杂度都是 O(1) 无环：prev和next 指针都指向 NULL 带表头指针和表尾指针：获取链表中节点数量的复杂度为 O(1) 带链表长度计数器：获取链表数量的复杂度为 O(1) 使用 列表键 发布与订阅 慢查询 监视器 字典12345678910111213141516typedef struct dictht &#123; // 哈希表数组 dictEntry **table; // 哈希表大小 unsigned long size; // 哈希表大小掩码，用于计算索引值 // 总是等于 size - 1 unsigned long sizemask; // 该哈希表已有节点的数量 unsigned long used;&#125; dictht; 属性rehashidx：记录rehash目前的进度，如果没有进行rehash那么值为-1 hash冲突Redis使用地址法（separate chaining）来解决键冲突，为了速度考虑， 程序总是将新节点添加到链表的表头位置。 rehash条件 load_factor = ht[0].used / ht[0].size 当服务器没有执行BGSAVE或者BGREWRITEAOF命令, load_factor &gt;=1，进行扩展 当服务器执行BGSAVE或者BGREWRITEAOF命令, load_factor&gt;=5，进行扩展 当 load_factor &lt; 0.1 时，进行收缩 渐进式rehash过程 ht[1]hash表分配空间，同时持有两个哈希表 扩展操作 ht[1] = ht[0].used * 2 收缩操作 ht[1] = ht[0].used 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0，表示 rehash 工作正式开始 每次增加、删除、更新或者查找，程序除了执行指定的操作外，还将ht[0]还是表在rehashidx上的所有键rehash到ht[1],rehashidx++ 将ht[0]上的所有键rehash到ht[1]上以后，rehashidx值设置为-1，表示完成 迁移完成之后，ht[1] = ht[0] ,释放ht[0]，在ht[1]新建一个空白的hash表 跳跃表123456789101112131415161718192021222324typedef struct zskiplistNode &#123; // 后退指针 struct zskiplistNode *backward; // 分值 double score; // 成员对象 robj *obj; // 层 struct zskiplistLevel &#123; // 前进指针 struct zskiplistNode *forward; // 跨度 unsigned int span; &#125; level[]; &#125; zskiplistNode; header ：指向跳跃表的表头节点。 tail ：指向跳跃表的表尾节点。 level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内），幂次定律，随机1-32。 length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。 幂次定律 整数集合123456789**typedef struct intset &#123; // 编码方式 uint32_t encoding; // 集合包含的元素数量 uint32_t length; // 保存元素的数组 int8_t contents[];&#125; intset;** 升级 编码类型 最小值 最大值 int16_t -32786 32767 int32_t -2147283648 2147283647 int64_t … … Q1:为什么要升级？ 压缩列表 压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型数据结构。 压缩列表只记录前一个字节点的长度 连锁更新，最坏的复杂度O(N²) 对象 Redis并没有直接使用上面的数据结构来实现，而是基于这些数据结构创建了一个对象系统，包括字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种对象，每种用到了上面至少一种数据类型 1234567891011121314151617typedef struct redisObject &#123; // 类型 unsigned type:4; // 编码 unsigned encoding:4; // 指向底层实现数据结构的指针 void *ptr; //引用计数器 int refcount // ...&#125; robj; 类型 对象 对象名称 REDIS_STRING 字符串对象 REDIS_LIST 列表对象 REDIS_HASH 哈希对象 REDIS_SET 集合对象 REDIS_ZSET 有序集合对象 底层实现 类型 编码 对象 REDIS_STRING REDIS_ENCODING_INT 使用整数值实现的字符串对象。 REDIS_STRING REDIS_ENCODING_EMBSTR 使用 embstr 编码的简单动态字符串实现的字符串对象。 REDIS_STRING REDIS_ENCODING_RAW 使用简单动态字符串实现的字符串对象。 REDIS_LIST REDIS_ENCODING_ZIPLIST 使用压缩列表实现的列表对象。 REDIS_LIST REDIS_ENCODING_LINKEDLIST 使用双端链表实现的列表对象。 REDIS_HASH REDIS_ENCODING_ZIPLIST 使用压缩列表实现的哈希对象。 REDIS_HASH REDIS_ENCODING_HT 使用字典实现的哈希对象。 REDIS_SET REDIS_ENCODING_INTSET 使用整数集合实现的集合对象。 REDIS_SET REDIS_ENCODING_HT 使用字典实现的集合对象。 REDIS_ZSET REDIS_ENCODING_ZIPLIST 使用压缩列表实现的有序集合对象。 REDIS_ZSET REDIS_ENCODING_SKIPLIST 使用跳跃表和字典实现的有序集合对象。 内存回收 通过引用计数法进行内存回收，若果refcount=0，则内存会被释放 对象共享 服务器初始化，创建一万个字符串对象，包含1-9999的所有整数值 Q2:为什么不共享包含字符串的对象或者多值对象？ 过期策略 策略 优点 缺点 定时删除 内存友好 CPU不友好 惰性删除 CPU友好 内存泄漏 定期删除 折中 执行时长和频率不好控制 持久化RDB持久化 将数据库的快照以二进制压缩文件的方式保存到磁盘 间隔自动保存 时间 次数 900 1 300 10 60 10000 AOF持久化 将所有写入命令及相关参数以协议文本的方式写入文件并持久保存磁盘 AOF 持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。 AOF持久化的安全与效率appendfsync always everysec no AOF重写 REWRITE: 在主线程中重写AOF，会阻塞工作线程，在生产环境 中很少使用，处于废弃状态； BGREWRITE: 在后台（子进程）重写AOF, 不会阻塞工作线程，能正常服务，此方法最常用。 AOF通过记录命令来记录数据库状态的，所以AOF文件的大小随着时间的流逝一定会越来越大，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件。 Q3：子进程重写期间，新的命令进来了怎么办？ 事件Redis服务器是一个事件驱动程序 文件事件 时间事件 ServerCron 每100ms执行一次 多机实现复制旧版复制 同步操作，从服务器更新至主服务器的状态 命令传播，主服务器发送命令进行同步 新版复制 复制偏移量 复制积压缓冲区，固定长度，FIFO，1M 服务器运行ID，启动时生成的40哥随机十六进制字符 心跳检测 每秒一次的频率 连接状态 检测命令丢失 哨兵 Sentinal Sentinal本质上只是一个在特殊模式下的Redis服务器 Sentinal初始化完成以后成为主服务器的客户端 命令连接 订阅连接 Q4:为什么会有两个连接？ 选举领头Sentinel 发现主服务器下线以后，都认为自己是局部领头 局部领头，先到先得 半数以上选举成功，没有接着选 故障转移 删除列表中处于下线或者断线的从服务器 删除列表中所有最近五秒没有回复过领头Sentinel命令的服务器 删除与主服务器超过 down-after-milliseconds * 10 ms 开始优先级排序 最高优先级-&gt;复制偏移量-&gt;运行服务器ID最小 集群 使用一致性hash实现，0-16384个slots 独立功能事务 非EXEC、DISCARD、WATCH、MULTI WATCH命令 WATCH命令是一个乐观锁，可以监视任意多的键，在EXEC执行之前会检查是否有值进行修改]]></content>
      <categories>
        <category>Nosql</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
